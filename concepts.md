[TOC]

------

## 缓存

缓存分类

1. 本地缓存，在内存中进行缓存，性能好，但容量小
    1. LRUMap
    2. Ehcache
2. 分布式缓存
    1. 需要进行远程请求。易扩展，性能不如本地缓存
3. 多级缓存
    1. 综合使用本地缓存和分布式缓存。热点数据使用本地缓存，其他使用分布式缓存



### LRUMap

> apache 的实现是双向循环链表
>
> get、moveToMRU（Most Recently Used）、put、updateEntry、

链表实现。在 get 方法中调用 moveToMRU 将 get 操作访问的项移动至链表头部。put 方法：没有重写 put 方法，重写了 put 方法中调用的 updateEntry 方法，并在其中调用 moveToMRU。则链表尾部就是那个最近最少使用的项



### 缓存雪崩

指大量的 key 在同一时间失效，同时有大量请求涌入，这一瞬间就像没有设置缓存一样，大量请求直接打到DB，如果DB没抗住就挂了

处理思路：批量设置 key 的过期时间时，增加一个随机数作为偏移值



### 缓存击穿

指针对一个热点数据，有大量请求，当其失效时，就有大量请求打到DB

处理思路

1. 热点数据永不失效，数据更新时主动更新缓存
2. 对数据库的访问加互斥锁，然后更新缓存



### 缓存穿透

指查询的数据不在DB中，自然不在缓存中。大量查询不在DB中的数据的请求就会直接打到DB

处理思路

1. 参数检验
2. bloomfilter，不存在的数据通过 bloomfilter 筛掉





## 队列

### 延时队列

一个队列，队列中的元素要求延时消费

实现方式  [参考](https://segmentfault.com/a/1190000022718540)

1. jdk 自带 DelayQueue
2. 定时任务
3. redis 的 sorted set，设置过期时时间戳作为排序的score
4. 开启 redis key 过期事件监听
5. RabbitMQ，设置消息过期时间和过期消息转发
6. 时间轮







## 散

### 符号常量和字面常量

- 符号常量
  - 用一个标识符来表示一个常量，这个标识符称之为符号常量
  - 如#define 定义、const定义、枚举定义
- 字面常量
  - 如 10、“haha”、10.10



### 动态规划（Dynamic Programming）

- 通俗的讲，就是记住求过的解来节省时间
- 记住求解的方式有两种：
  - 自顶向下的备忘录法：将求出的解用数组保存起来，下次再用时，直接取
  - 自底向上的动态规划：先计算子问题，再由子问题计算父问题
- 一般来说由于备忘录方式的动态规划方法使用了递归，递归的时候会产生额外的开销，使用自底向上的动态规划方法要比备忘录方法好

### 鸡尾酒排序

- 又叫定向冒泡排序，搅拌排序，来回排序
- 先找到最小的数字，把他放到第一位，然后找到最大的数字放到最后一位。然后再找到第二小的数字放到第二位，再找到第二大的数字放到倒数第二位。以此类推，直到完成排序



### 消息中间件

- 保证消息的投递可靠性，每个消息至少会被消费一次
- 保证不了消息不重复，因此消费逻辑需要自己实现幂等



### MurmurHash 算法

特点：快且随机，非加密型哈希函数。适用于对安全没有要求的场景











|            | C    | C++  | Java | Python | C#   |
| ---------- | ---- | ---- | ---- | ------ | ---- |
| 函数重载   |      | √    | √    | ×      | √    |
| 默认参数   |      | √    | ×    | √      |      |
| 运算符重载 |      | √    |      |        | √    |
| 接口       |      |      | √    | ×      | √    |





背景：什么问题？现状？问题规模？需不需要解决？解决带来什么收益

对于一个oncall问题：是需求，还是 bug？



- cerobro：对集群进行web可视化管理，如执行rest请求、修改Elasticsearch配置、监控实时的磁盘，集群负载，内存使用率等
- grafana：可以做数据监控和数据统计，带有告警功能。



ssh lighthouse@49.232.203.150

WXzJeBR4W2eGH-.

4tYLs!!TqVA7XXD

mysql cemwovQc5yHkpm  Sbiui7H7TxFT7b

 mycli -u xzw -h 49.232.203.150 -p Sbiui7H7TxFT7b



不读周边代码就没法写代码。写代码的难易程度取决于读周边代码的难易程度。

让每次签入时，代码都比签出时干净。持续改进

做的好的

1. 命名名副其实
2. 名称长短与作用域大小相对应
3. getXXX() 方法不要修改传入的参数。setXXX() 方法不要有返回值。一个方法尽量做到职责单一。会改变传入参数的方法要写好注释说明，改了哪些地方要说清楚。
4. 一个方法的参数不要太多，控制在 4 个以内。6、7个参数看起来很费劲。

做的不足

1. 方法中的抽象层次应该处于同一层次
2. 避免差别太小的命名。比如：XYZControllerForEfficientHandlingOfStrings 和 XYZControllerForEfficientStorageOfStrings
3. 不使用无意义的区分。例如 Product, Pr==oductInfo, ProductData. getOneStageData, gettingOneStageData, doingGetOneStageData
4. 统一命名风格，即唯一确定的命名对应的抽象概念。例如 get, fetch, retrieve。filter, getFiltered
5. 函数中的语句要在同一抽象层级上。重构的关键之一就是将函数拆分不同抽象层级

格式化考虑运算符的优先级，例如 `1*2 + 3*4`，加号左右有空格，乘号左右无空格







visitor 模式，双向分派