[TOC]
## React

#### 基础要点

##### 构造函数

- 在 JavaScript class 中，每次你定义其子类的构造函数时，都需要调用 `super` 方法。因此，在所有含有构造函数的的 React 组件中，构造函数必须以 `super(props)` 开头。

##### 不可变性在 React 中非常重要

- 简化复杂的功能
- 跟踪数据的改变
- 确定在 React 中何时重新渲染



#### 类型推断 Flow

- 安装：`npm install --global flow-bin`

- 在 VSCode 中：与内建TypeScript与JavaScript的检查功能冲突，需要设置`"javascript.validate.enable": false`

- 使用需要在文件中包含：`// @flow`

- 使用需要在项目文件夹下运行：`flow init`

- 类型注解：

  ```js
  // @flow
  // 原始类型：小写表示字面量（ literal values），
  function method(x: number, y: string, z: boolean) {
  }
  method(3.14, "hello", true);
  // 大写表示包装对象（wrapper objects），比如说等同于new String()
  function method(x: Number, y: String, z: Boolean) {
  }
  method(new Number(42), new String("world"), new Boolean(false));
  
  // 参数类型为函数
  function tryConvert(temperature, convert: (number) => void) {
  }
  ```



#### 创建 react app

``` sh
npx create-react-app my-app
cd my-app
npm start
```



#### 命名规范

- 将代表事件的监听 prop 命名为 `on[Event]`，将处理事件的监听方法命名为 `handle[Event]` 这样的格式
- 你应该在文件名中使用连字符。谷歌搜索引擎把连字符当作一个词的分隔符， 但不会以这种方式处理下划线



#### 重构技巧

- **当你遇到需要同时获取多个子组件数据，或者两个组件之间需要相互通讯的情况时，需要把子组件的 state 数据提升至其共同的父组件当中保存。之后父组件可以通过 props 将状态数据传递到子组件当中。这样应用当中所有组件的状态数据就能够更方便地同步共享了**



### React 初级

#### JSX 简介

- 因为 JSX 语法上更接近 JavaScript 而不是 HTML，所以 React DOM 使用 camelCase（小驼峰命名）来定义属性的名称，而不使用 HTML 属性名称的命名约定。

  例如，JSX 里的 **class 变成了 className**，而 tabindex 则变为 tabIndex。

- JSX 表示的是对象：Babel 会把 JSX 转译成一个名为 React.createElement() 函数调用。

- 例子

  ```jsx
  // 典型示例
  const element = <h1>Hello, world!</h1>;
  
  // 放在小括号中将jsx拆分为多行
  const element = (
      <h1>
        Hello, {formatName(user)}!
      </h1>
  );
  
  // 嵌入表达式：{name}
  const name = 'Josh Perez';
  const element = <h1>Hello, {name}</h1>;
  ReactDOM.render(
    element,
    document.getElementById('root')
  );
  ```



#### 元素渲染

- 元素是构成 React 应用的最小砖块。

- 元素描述了你在屏幕上想看到的内容。

- 与浏览器的 DOM 元素不同，React 元素是创建开销极小的普通对象。React DOM 会负责更新 DOM 来与 React 元素保持一致。

- 例子

  ```jsx
  // 想要将一个 React 元素渲染到根 DOM 节点中，只需把它们一起传入 ReactDOM.render()：
  const element = <h1>Hello, world</h1>;
  ReactDOM.render(element, document.getElementById('root'));
  
  // React 元素是不可变对象。一旦被创建，你就无法更改它的子元素或者属性。
  // 更新 UI 唯一的方式是创建一个全新的元素，并将其传入 ReactDOM.render()
  // 例如：
  function tick() {
    const element = (
      <div>
        <h1>Hello, world!</h1>
        <h2>It is {new Date().toLocaleTimeString()}.</h2>
      </div>
    );
    ReactDOM.render(element, document.getElementById('root'));
  }
  setInterval(tick, 1000);
  // 并且，React 只更新它需要更新的部分
  // 尽管每一秒我们都会新建一个描述整个 UI 树的元素，React DOM 只会更新实际改变了的内容，也就是例子中的文本节点：{new Date().toLocaleTimeString()}。
  ```



#### 组件 & Props

- 组件允许你将 UI 拆分为独立可复用的代码片段，并对每个片段进行独立构思

- 组件，从概念上类似于 JavaScript 函数。它接受任意的入参（即 “props”），并返回用于描述页面展示内容的 React 元素

-  组件名称必须以大写字母开头。React 会将以小写字母开头的组件视为原生 DOM 标签。

-  **所有 React 组件都必须像纯函数一样保护它们的 props 不被更改**

- 函数组件：

  ```jsx
  function Welcome(props) {
    return <h1>Hello, {props.name}</h1>;
  }
  ```

- class 组件

  ```jsx
  class Welcome extends React.Component {
    render() {
      return <h1>Hello, {this.props.name}</h1>;
    }
  }
  ```

- 组件渲染

  ```jsx
  function Welcome(props) {
    return <h1>Hello, {props.name}</h1>;
  }
  
  // 当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）转换为单个对象传递给组件，这个对象被称之为 “props”
  const element = <Welcome name="Sara" />;
  ReactDOM.render(
    element,
    document.getElementById('root')
  );
  ```

- 组合组件

  ``` jsx
  // 组件可以在其输出中引用其他组件。
  function Welcome(props) {
    return <h1>Hello, {props.name}</h1>;
  }
  
  function App() {
    return (
      <div>
        <Welcome name="Sara" />
        <Welcome name="Cahal" />
        <Welcome name="Edite" />
      </div>
    );
  }
  
  ReactDOM.render(
    <App />,
    document.getElementById('root')
  );
  ```



#### State & 生命周期

- 因为组件的 props 属性不可更改，但应用程序的 UI 是动态的，所以引入 state。

- 生命周期方法：

  - `componentDidMount()`：在组件被挂载（mount）后立即调用，在此处调用`setState()`会触发`re-rendering`
  - `componentWillUnmount()`：在组件即将销毁（卸载 / unmount）前调用，在此处释放`componentDidMount()`中占用的资源。

- 例子

  ```jsx
  const root = document.querySelector('#root');
  
  class Clock extends React.Component {
  
      constructor(props) {
          super(props);
          this.state = {date: new Date().toLocaleTimeString()};
      }
  
      componentDidMount() {
          // 将 setInterval() 赋给 this.timer，便于后面清除它
          this.timer = setInterval(() => {
              this.setState({date: new Date().toLocaleTimeString()});
          }, 1000);
      }
  
      // 在具有许多组件的应用程序中，当组件被销毁时释放所占用的资源是非常重要的
      componentWillUnmount() {
          clearInterval(this.timer);
      }
  
      render() {
          return (
              <div>
                  <h1>Hello World!</h1>
                  <h2>It is {this.state.date}</h2>
              </div>
          );
      }
  }
  
  ReactDOM.render(<Clock />, root);
  ```

- State 的更新可能是异步的

  因为 `this.props` 和 `this.state` 可能会异步更新，所以不要依赖他们的值来更新下一个状态。例如：

  ```jsx
  // Wrong：不能依赖state和props的值来更新下一个状态
  this.setState({
    counter: this.state.counter + this.props.increment,
  });
  
  // Correct：让setState()接受一个函数，让上一个state和props作为参数
  this.setState((state, props) => ({
    counter: state.counter + props.increment
  }));
  ```

- State 的更新会被合并：

  ```jsx
  constructor(props) {
      super(props);
      this.state = {
        posts: [],
        comments: []
      };
    }
  
  // 这里的合并是浅合并，所以 this.setState({comments}) 完整保留了 this.state.posts， 但是完全替换了 this.state.comments。
  fetchComments().then(response => {
        this.setState({
          comments: response.comments
        });
      });
    }
  ```

- 数据是向下流动的：

  这通常会被叫做“自上而下”或是“单向”的数据流。任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中“**低于**”它们的组件。



#### 事件处理

- React 事件的命名采用小驼峰式（camelCase），而不是纯小写

- 使用 JSX 语法时你需要传入一个用大括号包围的函数名，而不是一个字符串。

  ```jsx
// 传统HTML  
  <button onclick="activateLasers()">
    Activate Lasers
  </button>
  
  // React
  <button onClick={activateLasers}>
    Activate Lasers
  </button>
  ```
  
  ```jsx
  class Toggle extends React.Component {
    constructor(props) {
      super(props);
      this.state = {isT	oggleOn: true};
      // 为了在回调中使用 `this`，这个绑定是必不可少的
      // 在 JavaScript 中，class 的方法默认不会绑定 this。如果你忘记绑定 this.handleClick 并把它传入了 onClick，当你调用这个函数的时候 this 的值为 undefined
      // 调用bind()会创建一个新函数（原函数的拷贝），但新函数的this被bind的第一个参数指定，其余的参数将作为新函数的参数供调用时使用
      this.handleClick = this.handleClick.bind(this);
    }
  
    handleClick() {
      this.setState(state => ({
        isToggleOn: !state.isToggleOn
      }));
    }
  
    render() {
      return (
        <button onClick={this.handleClick}>
          {this.state.isToggleOn ? 'ON' : 'OFF'}
        </button>
      );
    }
  }
  
  ReactDOM.render(
    <Toggle />,
    document.getElementById('root')
  );
  
  // 如果觉得使用 bind 很麻烦，可以使用实验性的 public class fields 语法
  class LoggingButton extends React.Component {
    // 此语法确保 `handleClick` 内的 `this` 已被绑定。
    // 注意: 这是 *实验性* 语法。
    handleClick = () => {
      this.setState(state => ({	// 为什么state => 后的小括号不可以省略，或者说为什么要有
        isToggleOn: !state.isToggleOn
      }));
    }
  }
  
  // 或者，在调用时：创建一个新的匿名函数，调用this.handleClick()方法，不过有可能产生额外的开销
  render() {
      return (
        <button onClick={(e) => this.handleClick(e)}>
          Click me
        </button>
      );
    }
  ```



#### 条件渲染

- 与运算符 &&

  有趣的示例：

  ```jsx
  const root = document.querySelector('#root');
  
  function MailBox(props) {
      const len = props.len;
      return (
          <div>
              <h1>Hello</h1>
              { len > 0 &&
                  <h2>You have {len} unread messages</h2>
              }
          </div>
      );
      // 能这样做，是因为在 JavaScript 中，true && expression 总是会返回 expression, 而 false && expression 总是会返回 false
  }
  
  let messages = ['jack', 'joe', 'jane'];
  
  ReactDOM.render(<MailBox len={messages.length} />, root);
  ```

- 阻止组建渲染

  让 `render` 方法直接返回 `null`，可以不进行任何渲染



#### 列表 & key

- 只要构建动态列表的时候，都要指定一个合适的 key。

- 例如：

  ```jsx
  // @flow 
  const root = document.querySelector('#root');
  
  function MyList(props: {list: any[]}) {
      const list = props.list;
      // 若不指定key，则会触发一个警告
      // 并且，不建议使用索引来用作 key 值：如果列表项目的顺序可能会变化，会导致性能变差，还可能引起组件状态的问题
      // key 只是在兄弟节点之间必须唯一
      const lis = list.map((value, index) => (
          <li key={index}>
              {value}
          </li>
      ));
      return (
          <ul>
              {lis}
          </ul>
      );
  }
  let messages = ['jack', 'joe', 'jane'];
  ReactDOM.render(<MyList list={messages} />, root);
  ```




#### 表单

- 例子：input 和 textarea

  ```react
  class NameForm extends React.Component {
    constructor(props) {
      super(props);
      this.state = {value: ''};
  
      this.handleChange = this.handleChange.bind(this);
      this.handleSubmit = this.handleSubmit.bind(this);
    }
  
    handleChange(event) {
      this.setState({value: event.target.value});
    }
  
    handleSubmit(event) {
      alert('提交的名字: ' + this.state.value);
      event.preventDefault();
    }
  
    render() {
      return (
        <form onSubmit={this.handleSubmit}>
          <label>
            名字:
            <input type="text" value={this.state.value} onChange={this.handleChange} />
            <textarea value={this.state.value} onChange={this.handleChange} />
          </label>
          <input type="submit" value="提交" />
        </form>
      );
    }
  }
  ```

- 下拉菜单

  ```react
  class FlavorForm extends React.Component {
      constructor(props) {
          super(props);
          this.state = {value: 'coconut'};
  
          this.handleChange = this.handleChange.bind(this);
          this.handleSubmit = this.handleSubmit.bind(this);
      }
  
      handleChange(e) {
          this.setState({ value: e.target.value});
      }
  
      handleSubmit(e) {
          alert('你喜欢的风味是：' + this.state.value);
          e.preventDefault();
      }
  
      render() {
          return (
              <form onSubmit={this.handleSubmit}>
                  <label>
                      选择你喜欢的风味：
                      <select value={['peach', this.state.value]} onChange={this.handleChange} multiple={true}>
                          <option value="grapefruit">葡萄柚</option>
                          <option value="lime">酸橙</option>
                          <option value="coconut">椰子</option>
                          <option value="mango">芒果</option>
                          <option value ="peach">桃子</option>
                      </select>
                  </label>
                  <button>submit</button>
              </form>
          )
      }
  }
  ```

- 处理多个输入

  ```react
  class Reservation extends React.Component {
    constructor(props) {
      super(props);
      this.state = {
        isGoing: true,
        numberOfGuests: 2
      };
  
      this.handleInputChange = this.handleInputChange.bind(this);
    }
  
    handleInputChange(event) {
      const target = event.target;
      const value = target.type === 'checkbox' ? target.checked : target.value;
      const name = target.name;
  
      this.setState({
        [name]: value
      });
    }
  
    render() {
      return (
        <form>
          <label>
            参与:
            <input
              name="isGoing"
              type="checkbox"
              checked={this.state.isGoing}
              onChange={this.handleInputChange} />
          </label>
          <br />
          <label>
            来宾人数:
            <input
              name="numberOfGuests"
              type="number"
              value={this.state.numberOfGuests}
              onChange={this.handleInputChange} />
          </label>
        </form>
      );
    }
  }
  ```

  

#### 状态提升

- 在 React 中，将多个组件中需要共享的 state 向上移动到它们的最近共同父组件中，便可实现共享 state。这就是所谓的“状态提升”。

- ```react
  const root = document.querySelector('#root');
  
  function BoilingVerdict(props) {
  	if (props.celsius >= 100) {
  		return <p> The water is boiling </p>;
  	} else {
  		return <p> The water is not boiling </p>;
  	}
  }
  
  const scaleNames = {
  	c: 'Celsius',
  	f: 'Fahrenheit'
  };
  
  class TemperatureInput extends React.Component {
  	constructor(props) {
  		super(props);
  		this.handleChange = this.handleChange.bind(this);
  	}
  
  	handleChange(e) {
  		this.props.onTemperatureChange(e.target.value);
  	}
  
  	render() {
  		const temperature = this.props.temperature;
  		const scale = this.props.scale;
  		return (
  			<fieldset>
  				<legend> Enter temperature in {scaleNames[scale]}: </legend>
  				<input value={temperature} onChange={this.handleChange} />
  			</fieldset>
  		);
  	}
  }
  
  class Calculator extends React.Component {
  	constructor(props) {
  		super(props);
  		this.state = { temperature: '50', scale: 'c' };
  		this.handleCelsiusChange = this.handleCelsiusChange.bind(this);
  		this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this);
  	}
  
  	handleCelsiusChange(temperature) {
  		this.setState({ scale: 'c', temperature });
  	}
  
  	handleFahrenheitChange(temperature) {
  		this.setState({ scale: 'f', temperature });
  	}
  
  	render() {
  		const scale = this.state.scale;
  		const temperature = this.state.temperature;
  		const celsius = scale === 'f' ? tryConvert(temperature, toCelsius) : temperature;
  		const fahrenheit = scale === 'c' ? tryConvert(temperature, toFahrenheit)
  		 : temperature;
  		return (
  			<div>
  				<TemperatureInput scale="c" 
  				temperature={celsius} 
  				onTemperatureChange={this.handleCelsiusChange} />
  
  				<TemperatureInput scale="f" 
  				temperature={fahrenheit} 
  				onTemperatureChange={this.handleFahrenheitChange} />
  
  				<BoilingVerdict celsius={celsius} />
  			</div>
  		);
  	}
  }
  
  function toCelsius(fahrenheit) {
  	return (fahrenheit - 32) * 5 / 9;
  }
  
  function toFahrenheit(celsius) {
  	return celsius * 9 / 5 + 32;
  }
  
  function tryConvert(temperature, convert: number => void) {
  	const input = parseFloat(temperature);
  	if (Number.isNaN(input)) {
  		// 若为true，则表示input是NaN，即temperature不能转化为number
  		return '';
  	}
  	const output = convert(input);
  	const rounded = Math.round(output * 1000) / 1000;
  	return rounded.toString();
  }
  
  ReactDOM.render(<Calculator />, root);
  ```

#### 组合 vs 继承

- React 推荐使用**组合**而非继承来实现组件间的代码重用

#### React 哲学

```react
const root = document.querySelector('#root');

class Product {
	constructor(category, price, stocked, name) {
		this.category = category;
		this.price = price;
		this.stocked = stocked;
		this.name = name;
	}
}
let p1 = new Product('Sporting Goods', '$69.99', true, 'PingPong');

/**
 * 由上层传入category属性
 */
class ProductCategoryRow extends React.Component {
	render() {
		const category = this.props.category;
		return (
			<tr>
				<th colSpan="2">{category}</th>
			</tr>
		);
	}
}

/**
 * 由上层传入product对象
 */
class ProductRow extends React.Component {
	render() {
		const product = this.props.product;
		const name = product.stocked ? product.name : <span style={{ color: 'red' }}>{product.name}</span>;

		return (
			<tr>
				<td>{name}</td>
				<td>{product.price}</td>
			</tr>
		);
	}
}

class ProductTable extends React.Component<{ products: Product[] }> {
	render() {
		const filterText = this.props.filterText;
		const inStockOnly = this.props.inStockOnly;

		const rows = [];
		let productsByCategory = {};
		this.props.products.forEach((product) => {
			if (product.name.indexOf(filterText) === -1) {
				return;
			}
			if (inStockOnly && !product.stocked) {
				return;
			}
			if (Object.keys(productsByCategory).indexOf(product.category) !== -1) {
				productsByCategory[product.category].push(product);
			} else {
				productsByCategory[product.category] = [ product ];
			}
		});
		Object.entries(productsByCategory).forEach((entry) => {
			rows.push(<ProductCategoryRow category={entry[0]} key={entry[0]} />);
			entry[1].forEach((product) => {
				rows.push(<ProductRow product={product} key={product.name} />);
			});
		});

		return (
			<table>
				<thead>
					<tr>
						<th>Name</th>
						<th>Price</th>
					</tr>
				</thead>
				<tbody>{rows}</tbody>
			</table>
		);
	}
}

class SearchBar extends React.Component {
	handleFilterTextChange = (e) => {
		this.props.onFilterTextChange(e.target.value);
	};

	handleInStockChange = (e) => {
		this.props.onInStockChange(e.target.checked);
	};

	render() {
		const filterText = this.props.filterText;
		const inStockOnly = this.props.inStockOnly;
		return (
			<form>
				<input
					type="text"
					placeholder="Search..."
					value={this.filterText}
					onChange={this.handleFilterTextChange}
				/>
				<p>
					<input type="checkbox" checked={this.inStockOnly} onChange={this.handleInStockChange} />
					Only show products in stock
				</p>
			</form>
		);
	}
}

class FilterableProductTable extends React.Component {
	constructor(props) {
		super(props);
		this.state = {
			filterText: '',
			inStockOnly: false
		};
	}

	handleFilterTextChange = (text) => {
		this.setState({
			filterText: text
		});
	};

	handleInStockChange = (inStockOnly) => {
		this.setState({
			inStockOnly: inStockOnly
		});
	};

	render() {
		return (
			<div>
				<SearchBar
					filterText={this.state.filterText}
					inStockOnly={this.state.inStockOnly}
					onFilterTextChange={this.handleFilterTextChange}
					onInStockChange={this.handleInStockChange}
				/>
				<ProductTable
					products={this.props.products}
					filterText={this.state.filterText}
					inStockOnly={this.state.inStockOnly}
				/>
			</div>
		);
	}
}

const PRODUCTS = [
	{ category: 'Sporting Goods', price: '$49.99', stocked: true, name: 'Football' },
	{ category: 'Electronics', price: '$99.99', stocked: true, name: 'iPod Touch' },
	{ category: 'Sporting Goods', price: '$9.99', stocked: true, name: 'Baseball' },
	{ category: 'Electronics', price: '$399.99', stocked: false, name: 'iPhone 5' },
	{ category: 'Sporting Goods', price: '$29.99', stocked: false, name: 'Basketball' },
	{ category: 'Electronics', price: '$199.99', stocked: true, name: 'Nexus 7' },
	p1
];

ReactDOM.render(<FilterableProductTable products={PRODUCTS} />, root);
```









------

## JavaScript

#### 概念

- JavaScript 是轻量级解释型语言
- JavaScript 是一门完备的动态编程语言，可为网站添加交互功能
- 行末分号可有可无；推荐使用分号
- JavaScript 里一切皆对象，一切皆可储存在变量里

#### 基础要点

##### 等于 ===    不等于 !==

- 会测试**值**和**数据类型**是否相同
- 而 == 和 != 只判断**值**是否相同

##### 除法 - / 会保留小数

- 2 / 3 = 0.6666
- Math.floor(2 / 3)    或其他函数

##### 支持 ** 作为幂运算

- let a = 5 ** 5

##### 数组 - 用 [] 声明

- let myVariable = [1, '李雷', '韩梅梅', 10];

##### async 和 defer

- 浏览器遇到 `async` 脚本时不会阻塞页面渲染，而是直接下载然后运行。这样脚本的运行次序就无法控制，只是脚本不会阻止剩余页面的显示。当页面的脚本之间彼此独立，且不依赖于本页面的其它任何脚本时，`async` 是最理想的选择。如：

  ```html
  <script async src="js/vendor/jquery.js"></script>
  
  <script async src="js/script2.js"></script>
  
  <script async src="js/script3.js"></script>
  ```

  三者的调用顺序是不确定的。`jquery.js` 可能在 `script2` 和 `script3` 之前或之后调用，如果这样，后两个脚本中依赖 `jquery` 的函数将产生错误，因为脚本运行时 `jquery` 尚未加载。

- 使用 `defer` 属性，脚本将按照在页面中出现的顺序加载和运行

  ```html
  <script defer src="js/vendor/jquery.js"></script>
  
  <script defer src="js/script2.js"></script>
  
  <script defer src="js/script3.js"></script>
  ```

##### let & var

- let 用于声明变量（不能用 let 重复声明），以下内容会在第二行引发错误

  ```js
  let myName = 'Chris';
  let myName = 'Bob';		// 错误
  ```

- var ：没有理由再继续使用 var

  ```js
  var myName = 'Chris';
  var myName = 'Bob';		// 允许，但是不合理
  ```

##### 数值 <=> 字符串

```js
let myString = '123';
let myNum = Number(myString);

let myNum = 123;
let myString = myNum.toString();
```

#### 函数

##### concat - 合并数组

```js
var num1 = [[1]];
var num2 = [2, [3]];

var nums = num1.concat(num2);

console.log(nums);
// results in [[1], 2, [3]]

// modify the first element of num1
num1[0].push(4);

console.log(nums);
// results in [[1, 4], 2, [3]]
```

##### 模版字符串

```js
`string text ${expression} string text`		// 注意是反引号 `
```

```js
// 带标签的模板字符串
// 标签使您可以用函数解析模板字符串。标签函数的第一个参数包含一个字符串值的数组。其余的参数与表达式相关
var person = 'Mike';
var age = 28;

function myTag(strings, personExp, ageExp) {

  var str0 = strings[0]; // "that "
  var str1 = strings[1]; // " is a "

  // There is technically a string after
  // the final expression (in our example),
  // but it is empty (""), so disregard.
  // var str2 = strings[2];

  var ageStr;
  if (ageExp > 99){
    ageStr = 'centenarian';
  } else {
    ageStr = 'youngster';
  }

  return str0 + personExp + str1 + ageStr;

}

var output = myTag`that ${ person } is a ${ age }`;

console.log(output);
// that Mike is a youngster
```



##### slice - 字符串切片

```js
let browserType = 'mozilla';
browserType.slice(0,3);		// moz [0, 3)
browserType.slice(2);		// zilla [2, 最后]
browserType.slice(-2);		// la [-2, 最后]
browserType.slice(-4, -2);		// il [-4, -2)
```

- 与 python 类似：

  | m    | o    | z    | i    | l    | l    | a    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | 0    | 1    | 2    | 3    | 4    | 5    | 6    |
  | -7   | -6   | -5   | -4   | -3   | -2   | -1   |



##### addEventListener

- 给同一个监听器注册多个处理器:

    ```js
    // 下面这种方式不能实现这一点,第二行会覆盖第一行
    myElement.onclick = functionA;
    myElement.onclick = functionB;
    
    // 但是下面这种方式就会正常工作了：
    myElement.addEventListener('click', functionA);
    myElement.addEventListener('click', functionB);
    ```



##### preventDefault

```js
e.preventDefault();	// 阻止默认行为
```



##### Object.create()

- `create()` 实际做的是从指定原型对象创建一个新的对象。这里以 `person1` 为原型对象创建了 `person2` 对象。

```js
// 创建一个对象副本
let person2 = Object.create(person1);
```

```sh
p1.__proto__
{constructor: ƒ}
    constructor: ƒ Person(name)
    __proto__: Object
    
p2.__proto__
Person {name: "Jack", greeting: ƒ}
    greeting: ƒ ()
    name: "Jack"
    __proto__: Object
```



##### splice()

- **splice()** 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。

- 例如：

  ```js
  var months = ['Jan', 'March', 'April', 'June'];
  months.splice(1, 0, 'Feb');
  // inserts at index 1
  console.log(months);
  // expected output: Array ['Jan', 'Feb', 'March', 'April', 'June']
  
  months.splice(4, 1, 'May');
  // replaces 1 element at index 4
  console.log(months);
  // expected output: Array ['Jan', 'Feb', 'March', 'April', 'May']
  
  var myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];
  var removed = myFish.splice(2);
  // 运算后的 myFish: ["angel", "clown"]
  // 被删除的元素: ["mandarin", "sturgeon"]
  
  ```




##### setTimeout()

```js
function say() {
    alert('Hello Jack');
}
let flag = setTimeout(say, 2000);

// 传递给setTimeout的函数带参数
function say(name='Jack') {
    alert(`Hello ${name}`);
}
let flag = setTimeout(say, 2000, 'Rose');

// 取消超时调用
clearTimeout(flag);

// Immediate timeouts
// 在所有主线程运行完之后立即设置一个代码块来运行
setTimeout(function() {
  alert('World');
}, 0);
alert('Hello');

// Recursive setTimeout()
let i = 1;
setTimeout(function run() {
  console.log(i);
  i++;
  setTimeout(run, 100);
}, 100);
```



##### setInterval()

```js
function displayTime() {
    let date = new Date();
    let timeStr = date.toLocaleTimeString();
    document.querySelector('p').textContent = timeStr;
}
const createClock = setInterval(displayTime, 1000);

// 清除Intervals
clearInterval(createClock);

// 与上面Recursive setTimeout()效果相同
let i = 1;
setInterval(function run() {
  console.log(i);
  i++
}, 100);
// 那么Recursive setTimeout()与setInterval()有什么区别呢？
// 1. 上面的Recursive setTimeout()是在此次运行后，延迟100ms，运行下一次
// 2. 而setInterval()是两次开始运行的间隔是100ms，即此次开始运行（或将持续200ms），100ms后开始下一次运行
```



##### requestAnimationFrame()

- 专门为在浏览器中高效运行动画而创建的循环函数。它基本上是setInterval()的现代版本

- 为了解决setInterval()的问题：如setInterval()不会以设备优化的帧速率运行，有时会掉帧；即使选项卡不是活动选项卡或动画从页面上滚动，它也会继续运行

- 例如：

  ```js
  function draw() {
     // Drawing code goes here
     rAF = requestAnimationFrame(draw);
  }
  draw();
  
  // 取消
  cancelAnimationFrame(rAF);
  ```



##### cloneNode()

- `let dupNode = node.cloneNode(deep);`
- deep 可选，决定是否采用深度克隆，如果为true，则该节点的所有后代节点也都会被克隆，如果为false，则只克隆该节点本身
- 克隆一个元素节点会拷贝它所有的属性以及属性值,当然也就包括了属性上绑定的事件(比如onclick="alert(1)"),但不会拷贝那些使用addEventListener()方法或者node.onclick = fn这种用JavaScript动态绑定的事件.
- 如果原始节点设置了ID，那么应该更新克隆节点的ID以保证唯一性。name属性可能也需要进行修改，取决于你是否希望有相同名称的节点存在于文档中。



##### parseFloat()

```js
// 下面的例子都返回3.14
parseFloat("3.14");
parseFloat("314e-2");
parseFloat("0.0314E+2");
parseFloat("3.14more non-digit characters");
parseFloat('   3.14')

parseFloat("FF2");	// 返回NaN
```

##### Number.isNaN()

- 和全局函数 isNaN() 相比，该方法不会强制将参数转换成数字，只有在参数是真正的数字类型，且值为 NaN 的时候才会返回 true。

```js
Number.isNaN(NaN);        // true
Number.isNaN(Number.NaN); // true
Number.isNaN(0 / 0)       // true

// 下面这几个如果使用全局的 isNaN() 时，会返回 true。
Number.isNaN("NaN");      // false，字符串 "NaN" 不会被隐式转换成数字 NaN。
Number.isNaN(undefined);  // false
Number.isNaN({});         // false
Number.isNaN("blabla");   // false

// 下面的都返回 false
Number.isNaN(true);
Number.isNaN(null);
Number.isNaN(37);
Number.isNaN("37");
Number.isNaN("37.37");
Number.isNaN("");
Number.isNaN(" ");
```

##### in 的用法

```js
// 数组
var trees = new Array("redwood", "bay", "cedar", "oak", "maple");
0 in trees        // 返回true
3 in trees        // 返回true
6 in trees        // 返回false
"bay" in trees    // 返回false (必须使用索引号,而不是数组元素的值)

"length" in trees // 返回true (length是一个数组属性)

Symbol.iterator in trees // 返回true (数组可迭代，只在ES2015+上有效)


// 内置对象
"PI" in Math          // 返回true

// 自定义对象
var mycar = {make: "Honda", model: "Accord", year: 1998};
"make" in mycar  // 返回true
"model" in mycar // 返回true
```



#### 功能

##### 获得某个对象实例的构造器的名字

- instanceName.constructor.name



#### 事件冒泡和捕捉

- 当一个事件发生在具有父元素的元素上时，现代浏览器运行两个不同的阶段 - 捕获阶段和冒泡阶段

  - 捕获阶段：
    - 浏览器检查元素的最外层祖先 html，是否在捕获阶段中注册了一个 onclick 事件处理程序，如果是，则运行它。
    - 然后，它移动到 html 中单击元素的下一个祖先元素，并执行相同的操作，然后是单击元素再下一个祖先元素，依此类推，直到到达实际点击的元素。
  - 冒泡阶段，恰恰相反:
    - 浏览器检查实际点击的元素是否在冒泡阶段中注册了一个`onclick`事件处理程序，如果是，则运行它
    - 然后它移动到下一个直接的祖先元素，并做同样的事情，然后是下一个，等等，直到它到达`<html>`元素。

- 在现代浏览器中，**默认情况**下，所有事件处理程序都在冒泡阶段进行注册

- 用stopPropagation()修复问题：当在事件对象上调用该函数时，它只会让当前事件处理程序运行，但事件不会在**冒泡**链上进一步扩大

  ```js
  video.onclick = function(e) {
    e.stopPropagation();
    video.play();
  };
  ```



#### 事件委托

- 如果你想要在大量子元素中单击任何一个都可以运行一段代码，您可以将事件监听器设置在其父节点上，并将事件监听器气泡的影响设置为每个子节点，而不是每个子节点单独设置事件监听器。
- 一个很好的例子是一系列列表项，如果你想让每个列表点击时弹出一条信息，您可以将`click`单击事件监听器设置在父元素`<ul>`上，它将会冒泡到列表项上。



#### 构造函数

```js
function Person(first, last, age, gender, interests) {
    this.name = {
        first,		// 神奇的写法
        last
    };
    this.age = age;
    this.gender = gender;
    this.interests = interests;
};
```



#### 原型和原型链

- JavaScript 常被描述为一种**基于原型的语言 (prototype-based language)**——每个对象拥有一个**原型对象**，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为**原型链 (prototype chain)**。
- 原型链中的方法和属性**没有**被复制到其他对象——它们被访问需要通过前面所说的“原型链”的方式。
  - 上游对象的方法不会复制到下游的对象实例中；下游对象本身虽然没有定义这些方法，但浏览器会通过上溯原型链、从上游对象中找到它们。

#### 类

- ECMAScript 2015 中引入的、实质上是 JavaScript 现有的基于原型的继承的**语法糖**

- 类声明：一个类只能有一个构造函数

  ```js
  class Rectangle {
      constructor(height, width) {
          this.height = height;
          this.width = width;
      }
    
      // Getter
      get area() {
          return this.calcArea()
      }
      // Method
      // 这是一种把方法名直接赋给函数的简写方式
      calcArea() {
          return this.height * this.width;
      }
      
      // 静态方法
      static print() {
          console.log('I am a rectangle');
      }
  }
  
  // 方法简写，ECMAScript 2015 引入
  let obj = {
      foo: function () {
          /* code */
      },
      bar: function () {
          /* code */
      }
  };
  // 现可被简写为：
  var obj = {
    foo() {
      /* code */
    },
    bar() {
      /* code */
    }
  };
  // 速记语法还支持计算的属性名称。
  var bar = {
    foo0: function() { return 0; },
    foo1() { return 1; },
    ['foo' + 2]() { return 2; }
  };
  
  console.log(bar.foo0()); // 0
  console.log(bar.foo1()); // 1
  console.log(bar.foo2()); // 2
  ```

- 函数声明和类声明之间的一个重要区别是函数声明会**提升**，类声明不会。你首先需要声明你的类，然后访问它



#### 继承

- 方式一

  ```js
  function Person(first, last, age, gender, interests) {
    this.name = {
      first,
      last
    };
    this.age = age;
    this.gender = gender;
    this.interests = interests;
  };
  
  function Teacher(first, last, age, gender, interests, subject) {
    Person.call(this, first, last, age, gender, interests);
    this.subject = subject;
  }
  // 这意味着Teacher.prototype现在会继承Person.prototype的所有属性和方法
  Teacher.prototype = Object.create(Person.prototype);
  
  Teacher.prototype.constructor = Teacher;
  ```

- 方式二

  ```js
  class Animal { 
    constructor(name) {
      this.name = name;
    }
    
    speak() {
      console.log(this.name + ' makes a noise.');
    }
  }
  
  // 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。
  class Dog extends Animal {
    speak() {
      console.log(this.name + ' barks.');
    }
  }
  
  // 也可以扩展传统的基于函数的“类”：
  function Animal (name) {
    this.name = name;  
  }
  Animal.prototype.speak = function () {
    console.log(this.name + ' makes a noise.');
  }
  
  class Dog extends Animal {
    speak() {
      super.speak();
      console.log(this.name + ' barks.');
    }
  }
  
  // 类不能继承常规（非可构造）对象。如果要继承常规对象，可以改用Object.setPrototypeOf()：
  let Animal = {
    speak() {
      console.log(this.name + ' makes a noise.');
    }
  };
  
  class Dog {
    constructor(name) {
      this.name = name;
    }
  }
  
  Object.setPrototypeOf(Dog.prototype, Animal);// If you do not do this you will get a TypeError when you invoke speak
  
  var d = new Dog('Mitzie');
  d.speak(); // Mitzie makes a noise.
  ```



####  异步 JavaScript

- JavaScript 传统上是一种同步的、阻塞的、单线程的语言。
- 经过一段时间，JS获得了一些工具来解决这种问题. Web workers 可以把一些任务交给一个分离的线程，叫做worker, 所以你就可以同时运行多个JS代码块，一般来说，用一个worker来运行一个耗时的任务，main Thread就可以处理用户的交互（避免了阻塞）
- workers相当有用，但是他们的确也有局限。主要的一个就是不能访问 DOM — 它不能直接更新UI.

##### callbacks 函数实现异步（老派）

```js
btn.addEventListener('click', () => {
  alert('You clicked me!');

  let pElem = document.createElement('p');
  pElem.textContent = 'This is a newly-added paragraph.';
  document.body.appendChild(pElem);
});

// 当我们把回调函数作为一个参数传递给另一个函数时，仅仅是把回调函数定义作为参数传递过去 — 回调函数并没有立刻执行，回调函数会在包含它的函数的某个地方异步执行，包含函数负责在合适的时候执行回调函数。

// 注意，不是所有的回调函数都是异步的 — 有一些是同步的. 一个例子就是使用 Array.prototype.forEach() 来遍历数组 
```

##### promises 实现异步（新派）

- promise 是表示异步操作完成或失败的对象。可以说，它代表了一种中间状态。 本质上，这是浏览器说“我保证尽快给您答复”的方式，因此得名“promise”。

- 像promise这样的异步操作被放入事件队列中，**事件队列在主线程完成处理后运行**，这样它们就不会阻止后续JavaScript代码的运行。排队操作将尽快完成，然后将结果返回到JavaScript环境.

  例如

  ```js
  // 事件队列在主线程完成处理后运行
  console.log ('Starting');
  let image;
  
  fetch('coffee.jpg').then((response) => {
    console.log('It worked :)')
    return response.blob();
  }).then((myBlob) => {
    let objectURL = URL.createObjectURL(myBlob);
    image = document.createElement('img');
    image.src = objectURL;
    document.body.appendChild(image);
  }).catch((error) => {
    console.log('There has been a problem with your fetch operation: ' + error.message);
  });
  
  console.log ('All done!');
  
  // output: 
  // Starting
  // All done!
  // It worked :)
  ```
  
- Promise.all

  ```js
  function fetchAndDecode(url, type) {
      return fetch(url).then(response => {
          if (type === 'blob') {
              return response.blob();
          } else if (type === 'text') {
              return response.text();
          }
      }).catch(e => {
          console.log('There has been a problem with your fetch operation: ' + e.message);
      });
  }
  
  let coffee = fetchAndDecode('coffee.jpg', 'blob');
  let tea = fetchAndDecode('tea.jpg', 'blob');
  let description = fetchAndDecode('description.txt', 'text');
  
  Promise.all([coffee, tea, description]).then(values => {
      console.log(values);
      let coffeeURL = URL.createObjectURL(values[0]);
      let teaURL = URL.createObjectURL(values[1]);
      let descText = values[2];
  
      let img1 = document.createElement('img');
      let img2 = document.createElement('img');
      img1.src = coffeeURL;
      img2.src = teaURL;
      document.body.appendChild(img1);
      document.body.appendChild(img2);
  
      let para = document.createElement('p');
      para.textContent = descText;
      document.body.appendChild(para);
  });
  ```

- promise 构造函数

  ```js
  function timeoutPromise(message, interval) {
      return new Promise((resolve, reject) => {
          if (message === '' || typeof message !== 'string') {
              reject('Message is empty or not a string');
          } else if (interval < 0 || typeof interval !== 'number') {
              reject('Interval is negative or not a number');
          } else {
              setTimeout(() => resolve(message), interval);
          }
      });
  }
  
  timeoutPromise('Hello Jack', 1000)
      .then(msg => {
      	alert(msg)
  	}).catch(e => {
      	console.log('Error: ' + e);
  	});
  ```



##### async和await

###### async

- 将任何函数转换为promise

  ```js
  // 调用该函数会返回一个promise
  async function hello() { return "Hello" };
  hello();
  
  // 另外的写法
  let hello = async function() { return "Hello" };
  let hello = async () => { return "Hello" };
  ```

###### await

- 放在任何**基于异步声明的函数**之前，暂停代码在该行上，直到promise完成，然后返回结果值

- await 仅适用于异步函数

  ```js
  // 与上面用fetch().then().then()的代码功能相同
  async function myFetch() {
    try {
      let response = await fetch('coffee.jpg');
      let myBlob = await response.blob();
  
      let objectURL = URL.createObjectURL(myBlob);
      let image = document.createElement('img');
      image.src = objectURL;
      document.body.appendChild(image);
    } catch(e) {
      console.log(e);
    }
  }
  
  myFetch();
  ```
  
  ```js
  // 与上面 Promise.all 的代码功能相同
  async function fetchAndDecode(url, type) {
    let response = await fetch(url);
  
    let content;
  
    if(type === 'blob') {
      content = await response.blob();
    } else if(type === 'text') {
      content = await response.text();
    }
  
    return content;
  }
  
  async function displayContent() {
    let coffee = fetchAndDecode('coffee.jpg', 'blob');
    let tea = fetchAndDecode('tea.jpg', 'blob');
    let description = fetchAndDecode('description.txt', 'text');
  
    let values = await Promise.all([coffee, tea, description]);
  
    let objectURL1 = URL.createObjectURL(values[0]);
    let objectURL2 = URL.createObjectURL(values[1]);
    let descText = values[2];
  
    let image1 = document.createElement('img');
    let image2 = document.createElement('img');
    image1.src = objectURL1;
    image2.src = objectURL2;
    document.body.appendChild(image1);
    document.body.appendChild(image2);
  
    let para = document.createElement('p');
    para.textContent = descText;
    document.body.appendChild(para);
  }
  
  displayContent()
  .catch((e) =>
    console.log(e)
  );
  ```
  
- 一点缺陷：代码可能会因为大量等待的promises相继发生而变慢

  解决办法：

  ```js
  // 先后调用，依次等待做完，耗时9秒多
  async function timeTest() {
    await timeoutPromise(3000);
    await timeoutPromise(3000);
    await timeoutPromise(3000);
  }
  
  // 先同时调用，后续等待做完，耗时3秒多
  async function timeTest() {
    const timeoutPromise1 = timeoutPromise(3000);
    const timeoutPromise2 = timeoutPromise(3000);
    const timeoutPromise3 = timeoutPromise(3000);
  
    await timeoutPromise1;
    await timeoutPromise2;
    await timeoutPromise3;
  }
  ```



#### web APIs

##### 操作文档

- 例如

  ```html
  <section>
      <img src="dinosaur.png"
           alt="A red Tyrannosaurus Rex: A two legged dinosaur standing upright like a human, with small arms, and a large head with lots of sharp teeth.">
      <p>Here we will add a link to the <a href="https://www.mozilla.org/">Mozilla homepage</a></p>
  </section>
  
  <script>
      let link = document.querySelector('a');
      link.textContent = 'Mozilla Developer Network';
      link.href = 'https://developer.mozilla.org';
  
      let section = document.querySelector('section');
      let para = document.createElement('p');
      para.textContent = 'We hope you enjoyed the ride';
      
      // 操作css
      // 或者：para.setAttribute('class', 'highlight');
      // 然后在css文件中编写highlight类
      para.style.color = 'white';
      para.style.backgroundColor = 'black';
      para.style.padding = '10px';
      para.style.width = '250px';
      para.style.textAlign = 'center';
  
      section.appendChild(para)
  
      let text = document.createTextNode(' — the premier source for web development knowledge.');
      let linkPara = document.querySelector('p');
      linkPara.appendChild(text);
  
      // cloneNode(deep)，克隆节点
      // deep决定是否采用深度克隆,如果为true,则该节点的所有后代节点也都会被克隆,如果为false,则只克隆该节点本身
      let linkPara2 = linkPara.cloneNode(true);
      section.appendChild(linkPara2);
  
      linkPara2.parentNode.removeChild(linkPara2);
  </script>
  ```


##### 从服务器获取数据

- 进入目录文件夹，运行`python -m http.server` 可以搭建本地 http 服务器，运行 ajax 代码

- xmlHttpRequest

  ```js
  let requestURL = 'https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json';
  let xhr = new XMLHttpRequest();
  xhr.open('GET', requestURL);
  xhr.responseType = 'json';
  xhr.send();
  
  // 当请求对象load事件触发时执行代码
  xhr.onload = function () {
      // response 是一个 JavaScript 对象。这个对象是通过将接收到的数据类型视为 JSON 解析得到的。
      let superheroes = xhr.response;
      populateHeader(superheroes);
      showHeros(superheroes);
  };
  ```

- fetch

  ```js
  fetch('coffee.jpg')
      .then(response => response.blob())
      .then(myBlob => {
      let objectURL = URL.createObjectURL(myBlob);
      let image = document.createElement('img');
      image.src = objectURL;
      document.body.appendChild(image);
  })
      .catch(e => {
      console.log('There has been a problem with your fetch operation: ' + e.message);
  });
  ```




##### 绘图

- 例子

  ```js
  let canvas = document.querySelector('.myCanvas');
  let width = canvas.width = window.innerWidth;
  let height = canvas.height = window.innerHeight;
  let ctx = canvas.getContext('2d');
  
  // 绘制简单矩形（填充）
  ctx.fillStyle = 'rgb(0, 0, 0)';
  ctx.fillRect(0, 0, width, height);
  
  // 描边（未填充）
  ctx.strokeStyle = 'white';
  ctx.lineWidth = 5;
  ctx.strokeRect(25, 25, 175, 200);
  
  // 路径
  ctx.fillStyle = 'rgb(255, 0, 0)';
  ctx.beginPath();
  ctx.moveTo(50, 50);
  ctx.lineTo(150, 50);
  let triHeight = 50 * Math.tan(degToRad(60));
  ctx.lineTo(100, 50+triHeight);
  ctx.lineTo(50, 50);
  ctx.fill();
  
  // 画弧
  // 如果要填充一个没有首尾相接的路径，浏览器将在起、止点件绘制一条直线，然后直接填充。
  ctx.fillStyle = 'rgb(0, 0, 255)';
  ctx.beginPath();
  ctx.arc(150, 106, 50, degToRad(0), degToRad(360));  // 0° 设定为水平向右。
  ctx.fill();
  
  // 文字
  ctx.strokeStyle = 'white';
  ctx.lineWidth = 1;
  ctx.font = '36px arial';
  ctx.strokeText('Hello Jack', 50, 50);
  
  ctx.fillStyle = 'white';
  ctx.font = '48px georgia';
  ctx.fillText('Hello Jack', 50, 150);
  
  // 图片
  let img = new Image();
  img.src = 'firefox.png';
  img.addEventListener('load', () => {
      ctx.drawImage(img, 50, 50);
  });
  ```

  ```js
  // 使原点 (0, 0) 从画布左上顶点移动至画布正中心
  // 这个功能在许多场合非常实用，我们的绘制操作都是围绕着画布的中心点展开的。
  ctx.translate(width / 2, height / 2);
  ```



##### 客户端存储

- cookies：已淘汰

- Web Storage API：用于存储和检索较小的、由名称和相应值组成的数据项

  ```js
  // localStorage & sessionStorage
  localStorage.setItem('name', 'Jack');
  localStorage.getItem('name');
  localStorage.removeItem('name');
  ```

- IndexedDB API：为浏览器提供了一个完整的数据库系统来存储复杂的数据。这可以用于存储从完整的用户记录到甚至是复杂的数据类型，如音频或视频文件。

- Cache API：未来会使用



#### 严格模式

- ECMAScript 5 提出严格模式



#### 发送 json 数据

```html
<body>
    <button onclick="sendData({id: 3, provinceId :3, cityName: '北京', description: '北京天气不错'})">click me</button>

    <script>
        function sendData(data) {
            let xhr = new XMLHttpRequest();

            // 定义数据成功发送并返回后执行的操作
            xhr.addEventListener('load', event => alert('Yeah! 已发送数据并加载响应。'));

            // 定义发生错误时执行的操作
            xhr.addEventListener('error', event => alert('Oops! 出错了。'));

            xhr.open('POST', 'http://localhost:8080/api/city');
            xhr.setRequestHeader('Content-Type', 'application/json;charset=UTF-8');

            xhr.send(JSON.stringify(data));
        }
    </script>
</body>
```





------

## HTML

#### 要点

##### HTML 不是一门编程语言，而是一种用于定义内容结构的标记语言

##### !DOCTYPE html有什么用

- 混沌初分，HTML 尚在襁褓（大约是 1991/92 年），DOCTYPE 用来链接一些 HTML 编写守则，有点像自动校正等。然而现在已经没有人关心这些，只是因为历史原因必须将它们保留，但没有实际作用。

##### 什么是元素 - element

![HTML元素](images/element.png)

##### 添加作者和描述

- 一些内容管理系统能够自动获取页面作者的信息，然后用于某种目的
- description也被使用在搜索引擎显示的结果页中，这些行为术语上被称为 Search Engine Optimization, or SEO

```html
<meta name="author" content="Chris Mills">
<meta name="description" content="The MDN Learning Area aims to provide
complete beginners to the Web with all they need to know to get
started with developing web sites and applications.">
```

##### 添加 icon

```html
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
```

#### 链接

- title属性：可以在指针悬浮时，提供额外信息
- download属性：可以在下载链接中提供默认下载文件名

#### 描述列表 - description list

```html
<dl>
  <dt>内心独白</dt>
    <dd>戏剧中，某个角色对自己的内心活动或感受进行念白表演。</dd>
  <dt>语言独白</dt>
    <dd>戏剧中，某个角色把自己的想法直接进行念白表演，观众和其他角色都可以听到。</dd>
  <dt>旁白</dt>
    <dd>戏剧中，为渲染幽默或戏剧性效果而进行的场景之外的补充注释念白，只面向观众。</dd>
</dl>
```

#### 缩略语 - abbr

```html
<p>我们使用 <abbr title="超文本标记语言（Hypertext Markup Language）">HTML</abbr> 来组织网页文档。</p>
```

#### 图像

- 如果图像对您的内容里有意义，则应使用HTML图像。 如果图像纯粹是装饰，则应使用CSS背景图片。

- 用 figure 包围描述图片的重要文本

  ```html
  <figure>
    <img src="https://raw.githubusercontent.com/mdn/learning-area/master/html/multimedia-and-embedding/images-in-html/dinosaur_small.jpg"
       alt="一只恐龙头部和躯干的骨架，它有一个巨大的头，长着锋利的牙齿。"
       width="400"
       height="341">
    <figcaption>曼彻斯特大学博物馆展出的一只霸王龙的化石</figcaption>
  </figure>
  ```

#### 嵌入 iframe

```html
<iframe src="https://xieziwei99.github.io" frameborder="0" width="100%" height="500" allowfullscreen sandbox></iframe>
```



#### 矢量图形

- 相较于同样的位图，通常拥有更小的体积，因为它们仅需储存少量的算法，而不是逐个储存每个像素的信息。

##### SVG

- SVG 是用于描述矢量图像的 XML 语言



#### 表单

##### 单行文本框

```html
<input type="text" id="comment" name="comment" value="I'm a text field">
```

##### E-mail 地址框

```html
<!-- multiple属性，可以让用户输入多个电子邮件(以逗号分隔) -->
<input type="email" id="email" name="email" multiple>
```

##### 密码框

```html
<input type="password" id="pwd" name="pwd">
```

##### 搜索框

```html
<!-- 与普通文本框相比，可能给定一个“x”来清除输入的值 -->
<!-- 输入过的值可以被自动保存用来在同一站点上的多个页面上自动补全 -->
<input type="search" id="search" name="search">
```

##### 电话号码框

```html
<!-- 语义上的区别 -->
<input type="tel" id="tel" name="tel">
```

##### URL 栏

```html
<!-- 输入无效URL会报错 -->
<input type="url" id="url" name="url">
```

##### 多行文本框

```html
<!-- 与普通文本框相比，允许用户输入包含硬换行符(即按回车)的文本。 -->
<textarea cols="30" rows="10"></textarea>
```

##### 下拉框

```html
<select id="simple" name="simple" multiple>		<!-- 若设置multiple，则可以选择多个值 -->
  <option>Banana</option>
  <option>Cherry</option>
  <option>Lemon</option>
</select>

<select id="groups" name="groups">
  <optgroup label="fruits">
    <option>Banana</option>
    <option selected>Cherry</option>	<!-- selected默认选择 -->
    <option>Lemon</option>
  </optgroup>
  <optgroup label="vegetables">
    <option>Carrot</option>
    <option>Eggplant</option>
    <option>Potato</option>
  </optgroup>
</select>
```

##### 自动补全输入框

```html
<!-- 使用list属性将数据列表绑定到一个文本框 -->
<label for="myFruit">What's your favorite fruit?</label>
<input type="text" name="myFruit" id="myFruit" list="mySuggestion">
<datalist id="mySuggestion">
  <option>Apple</option>
  <option>Banana</option>
  <option>Blackberry</option>
  <option>Blueberry</option>
  <option>Lemon</option>
  <option>Lychee</option>
  <option>Peach</option>
  <option>Pear</option>
</datalist>
```

##### 单选框

```html
<fieldset>
  <legend>What is your favorite meal?</legend>
  <ul>
    <li>
      <label for="soup">Soup</label>
      <input type="radio" checked id="soup" name="meal" value="soup">  <!-- checked默认选中 -->
    </li>
    <li>
      <label for="curry">Curry</label>
      <input type="radio" id="curry" name="meal" value="curry">
    </li>
    <li>
      <label for="pizza">Pizza</label>
      <input type="radio" id="pizza" name="meal" value="pizza">
    </li>
  </ul>
</fieldset>
```

##### 复选框

- 将单选框中 type 改为`type="checkbox"`即可

##### 提交按钮

- 若不指定 `type`，则默认为 `submit`
- 若指定 `type="reset"`，则按下时会将所有表单小部件重新设置为它们的默认值
- 若指定`type="button"`，则按下不会自动生效，但可以使用 JavaScript 定制

```html
<button type="submit">
    This a <br><strong>submit button</strong>
</button>
```

##### 输入数字

```html
<input type="number" name="age" id="age" min="1" max="10" step="2">
```

##### 滑块

```html
<form>
    <input type="range" name="beans" id="beans" min="0" max="500" step="10">
    <span class="beancount"></span>
    <button type="submit">do</button>
</form>

<script>
    // 滑块不提供任何形式的视觉反馈，以了解当前的值是什么。需要使用JavaScript来添加这一点
    let beans = document.querySelector('#beans');
    let count = document.querySelector('.beancount');
    count.textContent = beans.value;
    beans.oninput = function () {
        count.textContent = beans.value;
    }
</script>
```

##### 日期时间选择器

```html
<!-- 本地时间（年月日小时分钟） -->
<input type="datetime-local" name="datetime" id="datetime">
<!-- 年月日 -->
<input type="date" name="myDate" min="2019-06-01" max="2019-08-31" id="myDate">
<!-- 月（包括某年） -->
<input type="month" name="month" id="month">
<!-- 时间（小时和分钟） -->
<input type="time" name="time" id="time">
<!-- 某年第几周 -->
<input type="week" name="week" id="week">
```

##### 拾色器

```html
<input type="color" name="color" id="color">
```

##### 文件选择器

```html
<!-- accept限制文件类型，multiple允许选择多个文件 -->
<input type="file" name="file" id="file" accept="image/*" multiple>
```

##### 表单隐藏内容

```html
<input type="hidden" id="timestamp" name="timestamp" value="1286705410">
```

##### 图像提交按钮

- 如果使用图像按钮来提交表单，会提交点击处相对于图像的 x 和 y 坐标（作为参数提交）

- 例如，点击时发送一个 url ：`http://foo.com?pos.x=123&pos.y=456` （其中 pos 是属性 name 的值）

  若没有指定 name，则为 `http://foo.com?x=123&y=456`

```html
<input type="image" alt="Click me!" src="my-img.png" width="80" height="30" name="pos" />
```

##### 进度条

```html
<!-- <progress>元素中的内容用于不支持该元素的浏览器的回退，以及辅助技术对其朗读 -->
<progress max="100" value="75">75/100</progress>        
```

#### 表单验证

- required 必须，pattern 正则匹配

  ```html
  <form>
    <label for="choose">Would you prefer a banana or a cherry?</label>
    <input id="choose" name="i_like" required pattern="banana|cherry">
    <button>Submit</button>
  </form>
  ```



------

## CSS

#### 要点

- CSS样式的JavaSript属性版本以小驼峰式命名法书写，而CSS版本带连接符号（`backgroundColor` 对 `background-color`）

##### 注释

- /* */，CSS 不接受 `//` 注释。

##### padding 顺序

- 上 右 下 左

##### 简单选择器

##### 通用选择器

- `*`

##### 属性选择器

- `[attr]`：选择包含 attr 属性的所有元素，不论 attr 的值为何。
- `[attr=val]`：仅选择 attr 属性被赋值为 val 的所有元素。
- `[attr~=val]`：选择具有 attr 属性的元素，而且要求 `val` 值是 `attr` 值包含的被空格分隔的取值列表里中的一个。
- `[attr|=val]` : 选择attr属性的值是 `val` 或值以 `val-` 开头的元素（注意，这里的 “-” 不是一个错误，这是用来处理语言编码的）。
- `[attr^=val]` : 选择attr属性的值以 `val` 开头（包括 `val`）的元素。
- `[attr$=val]` : 选择attr属性的值以 `val` 结尾（包括 `val`）的元素。
- `[attr*=val]` : 选择attr属性的值中包含子字符串 `val` 的元素（一个子字符串就是一个字符串的一部分而已，例如，”cat“ 是 字符串 ”caterpillar“ 的子字符串）

##### 伪类

- 如链接的伪类

  ```css
  /* 这些样式将在任何情况下应用于我们的链接 */
  a {
    color: blue;
    font-weight: bold;
  }
  
  /* 我们想让被访问过的链接和未被访问的链接看起来一样 */
  a:visited {
    color: blue;
  }
  
  /* 当光标悬停于链接，键盘激活或锁定链接时，我们让链接呈现高亮 */
  a:hover,
  a:active,
  a:focus {
    color: darkred;
    text-decoration: none;
  }
  ```

##### 伪元素

- 例如

  ```css
  /* 所有含有"href"属性并且值以"http"开始的元素，将会在其内容后增加一个箭头（去表明它是外部链接）*/
  [href^=http]::after {
    content: '⤴';
  }
  ```

##### 组合器

| 名称           | 组合器 | 选择                                                         |
| :------------- | :----- | :----------------------------------------------------------- |
| 选择器组       | A,B    | 匹配满足A（和/或）B的任意元素.                               |
| 后代选择器     | A B    | 匹配B元素，满足条件：B是A的后代结点（B是A的子节点，或者A的子节点的子节点） |
| 子选择器       | A > B  | 匹配B元素，满足条件：B是A的直接子节点                        |
| 相邻兄弟选择器 | A + B  | 匹配B元素，满足条件：B是A的下一个兄弟节点（AB有相同的父结点，并且B紧跟在A的后面） |
| 通用兄弟选择器 | A ~ B  | 匹配B元素，满足条件：B是A之后的任意一个兄弟节点（AB有相同的父节点，B在A之后，但不一定是紧挨着A） |



#### @-规则

##### @import

- `@import 'custom.css';` 向当前 CSS 导入其它 CSS 文件

##### @media

- 只有在运行浏览器的**设备匹配其表达条件时**才会应用该@-规则的内容

  ```css
  /* 只有在页面宽度超过801像素时才会应用 */
  @media (min-width: 801px) {
    body {
      margin: 0 auto;
      width: 800px;
    }
  }
  ```

##### @supports 

- 只有浏览器**确实支持被测功能时**才会应用该@-规则的内容；

##### @document 

- 只有当前页面**匹配一些条件时**才会应用该@-规则的内容。



#### 功能

##### 文字阴影 text-shadow

``` css
text-shadow: 3px 3px 1px black;
/* 
    第一个值设置水平偏移值 —— 即阴影右移的像素数（负值左移）。
    第二个值设置垂直偏移值 —— 即阴影下移的像素数（负值上移）。
    第三个值设置阴影的模糊半径 —— 值越大产生的阴影越模糊。
    第四个值设置阴影的基色。 
*/
```



##### 正方形图片显示为圆形

```css
img {
    display: block;
    margin: 0 auto;
    border-radius: 50%;
}
```



## HTTP

#### 概念点

- URI 的最常见形式是统一资源定位符 (URL)，它也被称为 Web 地址。
- HTTP协议的标准端口：HTTP为80，HTTPS为443
- 像浏览器这样的客户端发出的消息叫做 *requests*，被服务端响应的消息叫做 *responses*

##### 代理（Proxies）

- 在浏览器和服务器之间，有许多计算机和其他设备转发了HTTP消息
- 代理主要有如下作用：
  - 缓存（可以是公开的也可以是私有的，像浏览器的缓存）
  - 过滤（像反病毒扫描，家长控制...）
  - 负载均衡（让多个服务器服务不同的请求）
  - 认证（对不同资源进行权限管理）
  - 日志记录（允许存储历史信息）



#### [Data URLs](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/data_URIs)

- 什么东西？



#### MIME 类型（媒体类型）

- 格式：`type/subtype`

- 独立类型

  | 类型          | 描述                                                         | 典型示例                                                     |
  | :------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
  | `text`        | 表明文件是普通文本，理论上是人类可读                         | `text/plain`, `text/html`, `text/css, text/javascript`       |
  | `image`       | 表明是某种图像。不包括视频，但是动态图（比如动态gif）也使用image类型 | `image/gif`, `image/png`, `image/jpeg`, `image/bmp`, `image/webp`, `image/x-icon`, `image/vnd.microsoft.icon` |
  | `audio`       | 表明是某种音频文件                                           | `audio/midi`, `audio/mpeg, audio/webm, audio/ogg, audio/wav` |
  | `video`       | 表明是某种视频文件                                           | `video/webm`, `video/ogg`                                    |
  | `application` | 表明是某种二进制数据                                         | `application/octet-stream`, `application/pkcs12`, `application/vnd.mspowerpoint`, `application/xhtml+xml`, `application/xml`,  `application/pdf` |

- Multipart 类型

  - multipart/form-data： 可用于HTML表单从浏览器发送信息给服务器
  - multipart/byteranges：？？

- application/octet-stream：应用程序文件的默认值

- text/plain：文本文件默认值



#### 跨域资源共享（CORS）

- 浏览器限制从脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非响应报文包含了正确CORS响应头。



## Express

#### 要点

- 安装开发时需要的依赖，命令：`npm install eslint --save-dev`

##### express 应用生成器

- 运行 `npm install express-generator -g`，-g 参数可以把该工具全局安装，那样就可以在任意应用中使用了
- 进入目录，运行 `express hello`，创建一个名为 “hello” 的 express 应用，或者在当前目录下`express --view=pug`
- 进入生成的 hello 目录，`npm install` 安装依赖
- `SET DEBUG=hello:* & npm start` 运行应用（可以看到调试信息）
- 用 `npm start` 也可以启动应用，但没有调试信息

##### 热部署

1. 首先，全局安装 `nodemon` ：`npm install -g nodemon`
2. 然后，`DEBUG=local-library:* nodemon ./bin/www` 启动应用（包含调试信息和热部署）

- 或者将其作为开发依赖安装，步骤如下：

  1. `npm install --save-dev nodemon`

     那么，项目的 **package.json** 文件将自动添加一个新的属性：

     ```json
     "devDependencies": {
         "nodemon": "^1.18.9"
       }
     ```

  2. 在 package.json 的 `scripts` 部分，添加：

     ```json
     "scripts": {
         "start": "node ./bin/www",
         "devstart": "nodemon ./bin/www"
       },
     ```

  3. 现在，可以启动：`DEBUG=local-library:* npm run devstart` 



##### 用 express 生成的目录结构

- **package.json** ：文件中定义了应用依赖和其他信息
- **/bin/www** ：是应用入口，它做的第一件事是 `require()` “真实” 的应用入口（即项目根目录中的 **app.js** ）
- **app.js**：创建一个 `express` 应用对象（依照惯例命名为 `app`），通过各种设置选项和中间件来设置这个应用，然后从该模块中导出
-  **/routes文件夹**：路由
-  **/views目录**：视图（模版）



#### HelloWorld

- 进入当前文件夹，然后 `npm init`

- `npm install express` 程序入口默认为 `index.js` 

- 根目录创建 index.js：

  ```js
  const express = require('express');
  const app = express();
  
  app.get('/', (req, res) => res.send('<h1>Hello world</h1>'));
  
  app.listen(3000, () => console.log('Server started on http://localhost:3000'));
  ```

- 运行 `node index.js`



#### 使用数据库 (Mongoose)

- 简介
  - Mongoose：一款为异步工作环境设计的 MongoDB 对象建模工具。

- 使用
  - 安装 Mongoose 和 MongoDB 依赖项：`npm install mongoose` 
